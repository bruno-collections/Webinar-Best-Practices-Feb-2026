meta {
  name: Use Captured Data
  type: http
  seq: 3
}

get {
  url: {{baseUrl}}/posts/{{capturedPostId}}
  body: none
  auth: none
}

assert {
  res.status: eq 200
  res.body.id: isNumber
}

script:pre-request {
  const postId = bru.getVar("capturedPostId");
  
  if (!postId) {
    console.warn("âš ï¸ No captured post ID found! Run 'Capture and Reuse' first.");
  } else {
    console.log("ğŸ”— Using captured post ID:", postId);
  }
}

tests {
  test("Retrieved a valid post", () => {
    const body = res.getBody();
    expect(body).to.have.property("id");
    expect(body).to.have.property("title");
    expect(body).to.have.property("body");
  });
}

docs {
  # Use Captured Data ğŸ”—
  
  This request uses `{{capturedPostId}}` â€” a runtime variable set by the previous request.
  
  **Variable chaining flow:**
  1. **Capture and Reuse** â†’ creates a post â†’ saves the ID with `bru.setVar("capturedPostId", body.id)`
  2. **Use Captured Data** â†’ reads it via `{{capturedPostId}}` in the URL
  
  âš ï¸ **Run "Capture and Reuse" first!** Otherwise the variable won't exist yet.
  
  This pattern is essential for testing API workflows where one request depends on another's output.
}
