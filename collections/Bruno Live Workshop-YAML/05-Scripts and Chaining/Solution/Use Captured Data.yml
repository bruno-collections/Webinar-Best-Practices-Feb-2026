info:
  name: Use Captured Data
  type: http
  seq: 3

http:
  method: GET
  url: "{{baseUrl}}/posts/{{capturedPostId}}"

runtime:
  scripts:
    - type: before-request
      code: |-
        const postId = bru.getVar("capturedPostId");

        if (!postId) {
          console.warn("âš ï¸ No captured post ID found! Run 'Capture and Reuse' first.");
        } else {
          console.log("ğŸ”— Using captured post ID:", postId);
        }
    - type: tests
      code: |-
        test("Retrieved a valid post", () => {
          const body = res.getBody();
          expect(body).to.have.property("id");
          expect(body).to.have.property("title");
          expect(body).to.have.property("body");
        });
  assertions:
    - expression: res.status
      operator: eq
      value: "200"
    - expression: res.body.id
      operator: isNumber

settings:
  encodeUrl: true
  timeout: 0
  followRedirects: true
  maxRedirects: 5

docs: |-
  # Use Captured Data ğŸ”—

  This request uses `{{capturedPostId}}` â€” a runtime variable set by the previous request.

  **Variable chaining flow:**
  1. **Capture and Reuse** â†’ creates a post â†’ saves the ID with `bru.setVar("capturedPostId", body.id)`
  2. **Use Captured Data** â†’ reads it via `{{capturedPostId}}` in the URL

  âš ï¸ **Run "Capture and Reuse" first!** Otherwise the variable won't exist yet.

  This pattern is essential for testing API workflows where one request depends on another's output.
